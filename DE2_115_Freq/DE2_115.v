
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module DE2_115(

	//////////// CLOCK //////////
	CLOCK_50,
	CLOCK2_50,
	CLOCK3_50,

	//////////// LED //////////
	LEDG,
	LEDR,

	//////////// KEY //////////
	KEY,

	//////////// SW //////////
	SW,

	//////////// SEG7 //////////
	HEX0,
	HEX1,
	HEX2,
	HEX3,
	HEX4,
	HEX5,
	HEX6,
	HEX7,

	//////////// RS232 //////////
	UART_CTS,
	UART_RTS,
	UART_RXD,
	UART_TXD,

	//////////// I2C for HSMC  //////////
	I2C_SCLK,
	I2C_SDAT,

	//////////// GPIO, GPIO connect to GPIO Default - 1.8V //////////
	GPIO,

	//////////// HSMC, HSMC connect to HSMC Default - 1.8V //////////
	HSMC_CLKIN_N1,
	HSMC_CLKIN_N2,
	HSMC_CLKIN_P1,
	HSMC_CLKIN_P2,
	HSMC_CLKIN0,
	HSMC_CLKOUT_N1,
	HSMC_CLKOUT_N2,
	HSMC_CLKOUT_P1,
	HSMC_CLKOUT_P2,
	HSMC_CLKOUT0,
	HSMC_D,
	HSMC_RX_D_N,
	HSMC_RX_D_P,
	HSMC_TX_D_N,
	HSMC_TX_D_P
);

//=======================================================
//  PARAMETER declarations
//=======================================================


//=======================================================
//  PORT declarations
//=======================================================

//////////// CLOCK //////////
input 		          		CLOCK_50;
input 		          		CLOCK2_50;
input 		          		CLOCK3_50;

//////////// LED //////////
output		     [8:0]		LEDG;
output		    [17:0]		LEDR;

//////////// KEY //////////
input 		     [3:0]		KEY;

//////////// SW //////////
input 		    [17:0]		SW;

//////////// SEG7 //////////
output		     [6:0]		HEX0;
output		     [6:0]		HEX1;
output		     [6:0]		HEX2;
output		     [6:0]		HEX3;
output		     [6:0]		HEX4;
output		     [6:0]		HEX5;
output		     [6:0]		HEX6;
output		     [6:0]		HEX7;

//////////// RS232 //////////
output		          		UART_CTS;
input 		          		UART_RTS;
input 		          		UART_RXD;
output		          		UART_TXD;

//////////// I2C for HSMC  //////////
output		          		I2C_SCLK;
inout 		          		I2C_SDAT;

//////////// GPIO, GPIO connect to GPIO Default - 1.8V //////////
inout 		    [35:0]		GPIO;

//////////// HSMC, HSMC connect to HSMC Default - 1.8V //////////
input 		          		HSMC_CLKIN_N1;
input 		          		HSMC_CLKIN_N2;
input 		          		HSMC_CLKIN_P1;
input 		          		HSMC_CLKIN_P2;
input 		          		HSMC_CLKIN0;
inout		          		HSMC_CLKOUT_N1;
inout		          		HSMC_CLKOUT_N2;
inout		          		HSMC_CLKOUT_P1;
inout		          		HSMC_CLKOUT_P2;
inout		          		HSMC_CLKOUT0;
inout 		     [3:0]		HSMC_D;
inout 		    [16:0]		HSMC_RX_D_N;
inout 		    [16:0]		HSMC_RX_D_P;
inout 		    [16:0]		HSMC_TX_D_N;
inout 		    [16:0]		HSMC_TX_D_P;


//=======================================================
//  REG/WIRE declarations
//=======================================================
wire [28:0] counter;//needs to be modified each time
wire data_in;
wire sr1;

assign  HSMC_TX_D_N[1] = data_in;


//=======================================================
//  Structural coding
//=======================================================

dut_test_code inst_dut_test //dut_test_code maps pins from the fpga to the DUT
(
.button(KEY[0]), //only use button 0 for reset

.fpga_clk_out(HSMC_RX_D_P[0]),   //Counter clock
.fpga_clk_out_1(HSMC_TX_D_N[2]),  //CREST counter clock in

.pll_en_in(SW[1]), // RO Enable
.pll_en_out(HSMC_TX_D_P[2]),  //RO enable

.pll_sezro(HSMC_TX_D_P[1]),   // Select00RO
.pll_sezro_constant(), // SW[2]

.pll_seoro(HSMC_TX_D_P[0]),   // Select01RO
.pll_seoro_constant(), // SW[3]

.pll_sezDB(HSMC_TX_D_N[11]),
.pll_sezDB_constant(SW[4]),

.pll_seoDB(HSMC_RX_D_N[9]),
.pll_seoDB_constant(SW[5]),


.ext_data_to_dut(data_in), //connect to DUT CREST data pin to control either 1 or 0 input to shift registers
.ext_data_constant(SW[6]), //SW6 controls the external data input to the DUT


.ext_data_to_dutpattern(HSMC_TX_D_N[0]),  //data pattern control
.ext_datapattern_constant(SW[7]),


.osc_50(CLOCK_50), //system clock to dut_test_code. do not change unless necessary



//PLL inputs
//.pll_od2_in(1'b1),
//.pll_od1_in(1'b1),
.pll_od0_in(1'b1),
.pll_r4_in(1'b1),
.pll_r3_in(1'b1),
.pll_r2_in(1'b1),
.pll_r1_in(1'b1),
.pll_r0_in(1'b1),
.pll_f7_in(1'b1),
.pll_f6_in(1'b1),
.pll_f5_in(1'b1),
.pll_f4_in(1'b1),
.pll_f3_in(1'b1),
.pll_f2_in(1'b1),
.pll_f1_in(1'b1),
.pll_f0_in(1'b1),


// THE OUTPUTS are called sr27 s28 data27 and data28 and so on.
//----------------------------------------------------------



.crest_lbs_in(1'b0), //load=0, shift=0. this selects whether to load the values in the data & clk counters or to serially shift out the values in the counters
.crest_lbs_out(HSMC_RX_D_P[1]),


.crest_clr_in(1'b0), //clear the value stored in the data and clk counters
.crest_clr_out(HSMC_RX_D_N[0]),

//dut address bits. when doing alpha, heavy-ion, or laser testing, the address does not need to change since you can only test
//one chip at a time-----------------------
.dut_addr0_in(1'b0),
.dut_addr1_in(1'b0),
.dut_addr2_in(1'b1),
.dut_addr3_in(1'b0),
.dut_addr4_in(1'b0),
.dut_addr5_in(1'b0),

.dut_addr0_out(HSMC_TX_D_P[11]),
.dut_addr1_out(HSMC_RX_D_P[9]),
.dut_addr2_out(HSMC_TX_D_N[10]),
.dut_addr3_out(HSMC_TX_D_N[9]),
.dut_addr4_out(HSMC_TX_D_P[10]),
.dut_addr5_out(HSMC_TX_D_P[9]),
//------------------------------------------

//these are the outputs from the DUT
//data counter serial output pin
//
.data_out1(HSMC_CLKIN_N2),
.data_out2(HSMC_RX_D_N[16]),
.data_out3(HSMC_CLKIN_P2),
.data_out4(HSMC_RX_D_P[16]),
.data_out5(HSMC_TX_D_N[16]),
.data_out6(HSMC_RX_D_N[15]),
.data_out7(HSMC_TX_D_P[16]),
.data_out8(HSMC_RX_D_P[15]),
.data_out9(HSMC_TX_D_N[15]),
.data_out10(HSMC_RX_D_N[14]),
.data_out11(HSMC_RX_D_N[10]),
.data_out12(HSMC_TX_D_P[12]),
.data_out13(HSMC_TX_D_P[15]),
.data_out14(HSMC_RX_D_P[14]),
.data_out15(HSMC_TX_D_N[14]),
.data_out16(HSMC_RX_D_N[13]),
.data_out17(HSMC_TX_D_P[14]),
.data_out18(HSMC_RX_D_P[13]),
.data_out19(HSMC_CLKOUT_N2),
.data_out20(HSMC_RX_D_N[12]),
.data_out21(HSMC_CLKOUT_P2),

.data_out22(HSMC_RX_D_P[12]),
.data_out23(HSMC_TX_D_N[13]),
.data_out24(HSMC_RX_D_N[11]),
.data_out25(HSMC_TX_D_P[13]),
.data_out26(HSMC_RX_D_P[11]),

.data_out27(HSMC_TX_D_N[12]),
//.data_out28(HSMC_RX_D_N[5]),
//.data_out29(HSMC_TX_D_P[5]),


//
//these are the pins that are directed to the FPGA on board counters
.data_lsb_out27(counter[0]),
.data_lsb_out1(counter[1]),
.data_lsb_out2(counter[2]),
.data_lsb_out3(counter[3]),
.data_lsb_out4(counter[4]),
.data_lsb_out5(counter[5]),
.data_lsb_out6(counter[6]),
.data_lsb_out7(counter[7]),
.data_lsb_out8(counter[8]),
.data_lsb_out9(counter[9]),
.data_lsb_out10(counter[10]),
.data_lsb_out11(counter[11]),
.data_lsb_out12(counter[12]),
.data_lsb_out13(counter[13]),
.data_lsb_out14(counter[14]),
.data_lsb_out15(counter[15]),
.data_lsb_out16(counter[16]),
.data_lsb_out17(counter[17]),
.data_lsb_out18(counter[18]),
.data_lsb_out19(counter[19]),
.data_lsb_out20(counter[20]),
.data_lsb_out21(counter[21]),
.data_lsb_out22(counter[22]),
.data_lsb_out23(counter[23]),
.data_lsb_out24(counter[24]),
.data_lsb_out25(counter[25]),
.data_lsb_out26(counter[26]),


);
//this controls all counting. do not change anything here unless absolutely necessary

wire internal_reset; //internal reset signal that reset set and data counters

lsb_main lsb_main_test
(

.reset(KEY[0]),
.sys_clk(CLOCK_50),
.counter_in0(counter[0]),
.counter_in1(counter[1]),
.counter_in2(counter[2]),
.counter_in3(counter[3]),
.counter_in4(counter[4]),
.counter_in5(counter[5]),
.counter_in6(counter[6]),
.counter_in7(counter[7]),
.counter_in8(counter[8]),
.counter_in9(counter[9]),
.counter_in10(counter[10]),
.counter_in11(counter[11]),
.counter_in12(counter[12]),
.counter_in13(counter[13]),
.counter_in14(counter[14]),
.counter_in15(counter[15]),
.counter_in16(counter[16]),
.counter_in17(counter[17]),
.counter_in18(counter[18]),
.counter_in19(counter[19]),
.counter_in20(counter[20]),
.counter_in21(counter[21]),
.counter_in22(counter[22]),
.counter_in23(counter[23]),
.counter_in24(counter[24]),
.counter_in25(counter[25]),
.counter_in26(counter[26]),
.counter_in27(counter[27]),

//serial ports
.serial_in(UART_RXD),
.serial_out(UART_TXD)




);//end lsb_main test
endmodule
